<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>GET 与 POST 的区别</title>
      <link href="2021/03/14/get%E4%B8%8Epost%E5%8C%BA%E5%88%AB/"/>
      <url>2021/03/14/get%E4%B8%8Epost%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="GET-与-POST-的区别"><a href="#GET-与-POST-的区别" class="headerlink" title="GET 与 POST 的区别"></a>GET 与 POST 的区别</h1><h3 id="99-的人都理解错了-HTTP-中-GET-与-POST-的区别"><a href="#99-的人都理解错了-HTTP-中-GET-与-POST-的区别" class="headerlink" title="99% 的人都理解错了 HTTP 中 GET 与 POST 的区别"></a>99% 的人都理解错了 HTTP 中 GET 与 POST 的区别</h3><p>GET 和 POST 是 HTTP 请求的两种基本方法，要说它们的区别，接触过 WEB 开发的人都能说出一二。</p><p>最直观的区别就是 GET 把参数包含在 URL 中，POST 通过 request body 传递参数。</p><p>你可能自己写过无数个 GET 和 POST 请求，或者已经看过很多权威网站总结出的他们的区别，你非常清楚知道什么时候该用什么。当你在面试中被问到这个问题，你的内心充满了自信和喜悦。</p><p>你轻轻松松的给出了一个“标准答案”：</p><h5 id="GET-在浏览器回退时是无害的，而-POST-会再次提交请求。"><a href="#GET-在浏览器回退时是无害的，而-POST-会再次提交请求。" class="headerlink" title="GET 在浏览器回退时是无害的，而 POST 会再次提交请求。"></a>GET 在浏览器回退时是无害的，而 POST 会再次提交请求。</h5><h5 id="GET-产生的-URL-地址可以被-Bookmark，而-POST-不可以。"><a href="#GET-产生的-URL-地址可以被-Bookmark，而-POST-不可以。" class="headerlink" title="GET 产生的 URL 地址可以被 Bookmark，而 POST 不可以。"></a>GET 产生的 URL 地址可以被 Bookmark，而 POST 不可以。</h5><h5 id="GET-请求会被浏览器主动-cache，而-POST-不会，除非手动设置。"><a href="#GET-请求会被浏览器主动-cache，而-POST-不会，除非手动设置。" class="headerlink" title="GET 请求会被浏览器主动 cache，而 POST 不会，除非手动设置。"></a>GET 请求会被浏览器主动 cache，而 POST 不会，除非手动设置。</h5><h5 id="GET-请求只能进行-URL-编码，而-POST-支持多种编码方式。"><a href="#GET-请求只能进行-URL-编码，而-POST-支持多种编码方式。" class="headerlink" title="GET 请求只能进行 URL 编码，而 POST 支持多种编码方式。"></a>GET 请求只能进行 URL 编码，而 POST 支持多种编码方式。</h5><h5 id="GET-请求参数会被完整保留在浏览器历史记录里，而-POST-中的参数不会被保留。"><a href="#GET-请求参数会被完整保留在浏览器历史记录里，而-POST-中的参数不会被保留。" class="headerlink" title="GET 请求参数会被完整保留在浏览器历史记录里，而 POST 中的参数不会被保留。"></a>GET 请求参数会被完整保留在浏览器历史记录里，而 POST 中的参数不会被保留。</h5><h5 id="GET-请求在-URL-中传送的参数是有长度限制的，而-POST-么有。"><a href="#GET-请求在-URL-中传送的参数是有长度限制的，而-POST-么有。" class="headerlink" title="GET 请求在 URL 中传送的参数是有长度限制的，而 POST 么有。"></a>GET 请求在 URL 中传送的参数是有长度限制的，而 POST 么有。</h5><h5 id="对参数的数据类型，GET-只接受-ASCII-字符，而-POST-没有限制。"><a href="#对参数的数据类型，GET-只接受-ASCII-字符，而-POST-没有限制。" class="headerlink" title="对参数的数据类型，GET 只接受 ASCII 字符，而 POST 没有限制。"></a>对参数的数据类型，GET 只接受 ASCII 字符，而 POST 没有限制。</h5><h5 id="GET-比-POST-更不安全，因为参数直接暴露在-URL-上，所以不能用来传递敏感信息。"><a href="#GET-比-POST-更不安全，因为参数直接暴露在-URL-上，所以不能用来传递敏感信息。" class="headerlink" title="GET 比 POST 更不安全，因为参数直接暴露在 URL 上，所以不能用来传递敏感信息。"></a>GET 比 POST 更不安全，因为参数直接暴露在 URL 上，所以不能用来传递敏感信息。</h5><h5 id="GET-参数通过-URL-传递，POST-放在-Request-body-中。"><a href="#GET-参数通过-URL-传递，POST-放在-Request-body-中。" class="headerlink" title="GET 参数通过 URL 传递，POST 放在 Request body 中。"></a>GET 参数通过 URL 传递，POST 放在 Request body 中。</h5><p>“很遗憾，这不是我们要的回答！”</p><p>请告诉我真相。。。</p><p>如果我告诉你 GET 和 POST 本质上没有区别你信吗？ </p><p>让我们扒下 GET 和 POST 的外衣，坦诚相见吧！</p><p>GET 和 POST 是什么？HTTP 协议中的两种发送请求的方法。</p><h4 id="HTTP是什么？"><a href="#HTTP是什么？" class="headerlink" title="HTTP是什么？"></a>HTTP是什么？</h4><p>HTTP 是基于 TCP/IP 的关于数据如何在万维网中如何通信的协议。</p><p>HTTP 的底层是 TCP/IP，所以 GET 和 POST 的底层也是 TCP/IP，也就是说，GET/POST 都是 TCP 链接。</p><p>GET 和 POST 能做的事情是一样一样的。你要给 GET 加上 request body，给 POST 带上 url 参数，技术上是完全行的通的。 </p><p>那么，“标准答案”里的那些区别是怎么回事？</p><p>在我大万维网世界中，TCP 就像汽车，我们用 TCP 来运输数据，它很可靠，从来不会发生丢件少件的现象。</p><p>但是如果路上跑的全是看起来一模一样的汽车，那这个世界看起来是一团混乱，送急件的汽车可能被前面满载货物的汽车拦堵在路上，整个交通系统一定会瘫痪。</p><p>为了避免这种情况发生，交通规则 HTTP 诞生了。</p><p>HTTP 给汽车运输设定了好几个服务类别，有 GET, POST, PUT, DELETE 等等。</p><p>HTTP 规定，当执行 GET 请求的时候，要给汽车贴上 GET 的标签（设置 method 为 GET），而且要求把传送的数据放在车顶上（url 中）以方便记录。</p><p>如果是 POST 请求，就要在车上贴上 POST 的标签，并把货物放在车厢里。</p><p>当然，你也可以在 GET 的时候往车厢内偷偷藏点货物，但是这是很不光彩；也可以在 POST 的时候在车顶上也放一些数据，让人觉得傻乎乎的。</p><p>HTTP 只是个行为准则，而 TCP 才是 GET 和 POST 怎么实现的基本。</p><p>但是，我们只看到 HTTP 对 GET 和 POST 参数的传送渠道（url 还是 requrest body）提出了要求。</p><h5 id="“标准答案”里关于参数大小的限制又是从哪来的呢？"><a href="#“标准答案”里关于参数大小的限制又是从哪来的呢？" class="headerlink" title="“标准答案”里关于参数大小的限制又是从哪来的呢？"></a>“标准答案”里关于参数大小的限制又是从哪来的呢？</h5><p>在我大万维网世界中，还有另一个重要的角色：运输公司。</p><p>不同的浏览器（发起 http 请求）和服务器（接受 http 请求）就是不同的运输公司。 </p><p>虽然理论上，你可以在车顶上无限的堆货物（url 中无限加参数）。</p><p>但是运输公司可不傻，装货和卸货也是有很大成本的，他们会限制单次运输量来控制风险，数据量太大对浏览器和服务器都是很大负担。业界不成文的规定是，（大多数）浏览器通常都会限制 url 长度在 2K 个字节，而（大多数）服务器最多处理 64K 大小的 url。超过的部分，恕不处理。</p><p>如果你用 GET 服务，在 request body 偷偷藏了数据，不同服务器的处理方式也是不同的，有些服务器会帮你卸货，读出数据，有些服务器直接忽略，所以，虽然 GET 可以带 request body，也不能保证一定能被接收到哦。</p><p>好了，现在你知道，GET 和 POST 本质上就是 TCP 链接，并无差别。</p><p>但是由于 HTTP 的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。 </p><p>你以为本文就这么结束了？</p><p>我们的大 BOSS 还等着出场呢。。。</p><p>这位 BOSS 有多神秘？</p><p>当你试图在网上找“GET 和 POST 的区别”的时候，那些你会看到的搜索结果里，从没有提到他。</p><p>他究竟是什么呢。。。</p><p>GET 和 POST 还有一个重大区别，简单的说：GET 产生一个 TCP 数据包；POST 产生两个 TCP 数据包。</p><p>长的说：对于 GET 方式的请求，浏览器会把 http header 和 data 一并发送出去，服务器响应 200（返回数据）；而对于 POST，浏览器先发送 header，服务器响应 100（continue），浏览器再发送 data，服务器响应 200（返回数据）。</p><p>也就是说，GET 只需要汽车跑一趟就把货送到了，而 POST 得跑两趟，第一趟，先去和服务器打个招呼：“嗨，我等下要送一批货来，你们打开门迎接我”，然后再回头把货送过去。</p><p>因为 POST 需要两步，时间上消耗的要多一点，看起来 GET 比 POST 更有效。</p><p>因此 Yahoo 团队有推荐用 GET 替换 POST 来优化网站性能。</p><p>但这是一个坑！！！跳入需谨慎。</p><p>为什么？</p><p>GET 与 POST 都有自己的语义，不能随便混用。<br>据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的 TCP 在验证数据包完整性上，有非常大的优点。<br>并不是所有浏览器都会在 POST 中发送两次包，比如 Firefox 就只发送一次。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2021/01/20/hello-world/"/>
      <url>2021/01/20/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: [Deployment</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2020/05/25/JQuery%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>2020/05/25/JQuery%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么要学jquery"><a href="#为什么要学jquery" class="headerlink" title="为什么要学jquery"></a>为什么要学jquery</h2><p>使用javascript开发过程中，有许多的缺点：</p><p>查找元素的方法单一，麻烦。<br>遍历数组很麻烦，通常要嵌套一大堆的for循环。<br>有兼容性问题。<br>想要实现简单的动画效果，也很麻烦<br>代码冗余。</p><h4 id="体验jquery的使用"><a href="#体验jquery的使用" class="headerlink" title="体验jquery的使用"></a>体验jquery的使用</h4><p>/*</p><ul><li><ol><li>查找元素的方法多种多样，非常灵活</li></ol></li><li><ol start="2"><li>拥有隐式迭代特性，因此不再需要手写for循环了。</li></ol></li><li><ol start="3"><li>完全没有兼容性问题。</li></ol></li><li><ol start="4"><li>实现动画非常简单，而且功能更加的强大。</li></ol></li><li><ol start="5"><li>代码简单、粗暴。</li></ol></li><li>*/<br>$(document).ready(function () {<br>  $(“#btn1”).click(function () {<pre><code>  $(&quot;div&quot;).show(200);</code></pre>  });<br>  $(“#btn2”).click(function () {<pre><code>  $(&quot;div&quot;).text(&quot;我是内容&quot;);</code></pre>  });<br>});</li></ul><h3 id="jquery到底是什么"><a href="#jquery到底是什么" class="headerlink" title="jquery到底是什么"></a>jquery到底是什么</h3><p>jQuery的官网 <a href="http://jquery.com/">http://jquery.com/</a><br>jQuery就是一个js库，使用jQuery的话，会比使用JavaScript更简单。</p><p>What is jQuery?</p><p>   jQuery is a fast, small, and feature-rich JavaScript library.<br>   It makes things like HTML document traversal and manipulation,<br>   event handling, animation, and Ajax<br>   much simpler with an easy-to-use API that works across a multitude of browsers.<br>   With a combination of versatility and extensibility,<br>   jQuery has changed the way that millions of people write JavaScript. </p><p>js库：把一些常用到的方法写到一个单独的js文件，使用的时候直接去引用这js文件就可以了。<br>（animate.js、common.js）</p><p>我们知道了，jQuery其实就是一个js文件，里面封装了一大堆的方法方便我们的开发，<br>其实就是一个加强版的common.js，因此我们学习jQuery，其实就是学习jQuery这个js文件中封装的一大堆方法。</p><p>jquery的版本问题<br>官网下载地址：<a href="http://jquery.com/download/">http://jquery.com/download/</a><br>jQuery版本有很多，分为1.x 2.x 3.x<br>1.x和2.x版本jquery都不再更新版本了，现在只更新3.x版本。</p><p>大版本分类：</p><p>1.x版本：能够兼容IE678浏览器<br>2.x版本：不能兼容IE678浏览器<br>3.x版本：不能兼容IE678浏览器，更加的精简（在国内不流行，因为国内使用jQuery的主要目的就是兼容IE678）<br>关于压缩版和未压缩版：</p><p>jquery-1.12.4.min.js:压缩版本，适用于生产环境，因为文件比较小，去除了注释、换行、空格等东西，但是基本没有颗阅读性。<br>jquery-1.12.4.js:未压缩版本，适用于学习与开发环境，源码清晰，易阅读。<br>jquery的入口函数<br>使用jQuery的三个步骤：</p><p>引入jQuery文件<br>入口函数<br>功能实现<br>关于jQuery的入口函数：</p><p>//第一种写法<br>$(document).ready(function() {</p><p>});<br>//第二种写法<br>$(function() {</p><p>});</p><p>jQuery入口函数与js入口函数的对比：</p><p>JavaScript的入口函数要等到页面中所有资源（包括图片、文件）加载完成才开始执行。<br>jQuery的入口函数只会等待文档树加载完成就开始执行，并不会等待图片、文件的加载。</p><script>  //1.$是什么?  //如果报了这个错误:$ is not defined,就说明没有引入jQuery文件.  // $(function () {  //  // });  //2.jQuery文件结构.  //其实是一个自执行函数.  // (function(){  //   window.jQuery = window.$ = jQuery;  // }());  //3.  //a.引入一个js文件,是会执行这js文件中的代码的.  //console.log(num);//10  //b.jQuery文件是一个自执行函数,执行这个jQUERY文件中的代码,其实就是执行这个自执行函数.  //c.这个自执行文件就是给window对象添加一个jQuery属性和$属性.  //console.log(window);  //d.$其实和jQuery是等价的,是一个函数.  // console.log(window.jQuery === window.$);//true  // console.log(Object.prototype.toString.call($));//'[object Function]'  //4.$是一个函数  //参数传递不同,效果也不一样.  //4.1 如果参数传递的是一个匿名函数-入口函数  // $(function(){  // });  //4.2 如果参数传递的是一个字符串-选择器/创建一个标签  //$('#one');  //$('<div>啦啦,我是一个div</div>');  //4.3 如果参数是一个dom对象,那他就会把dom对象转换成jQuery对象.  //$(dom对象);r $obj = $(domObj);// $(document).ready(function(){});就是典型的DOM对象转jQuery对象jQuery对象转换成DOM对象：var $li = $("li");//第一种方法（推荐使用）$li[0]//第二种方法$li.get(0)12345### jquery选择器什么是jQuery选择器jQuery选择器是jQuery为我们提供的一组方法，让我们更加方便的获取到页面中的元素。注意：jQuery选择器返回的是jQuery对象。jQuery选择器有很多，基本兼容了CSS1到CSS3所有的选择器，并且jQuery还添加了很多扩展性的选择器。【查看jQuery文档】jQuery选择器虽然很多，但是选择器之间可以相互替代，就是说获取一个元素，你会有很多种方法获取到。所以我们平时真正能用到的只是少数的最常用的选择器。基本选择器名称    用法    描述ID选择器    $(“#id”);    获取指定ID的元素类选择器    $(“.class”);    获取同一类class的元素标签选择器    $(“div”);    获取同一类标签的所有元素并集选择器    $(“div,p,li”);    使用逗号分隔，只要符合条件之一就可。交集选择器    $(“div.redClass”);    获取class为redClass的div元素总结：跟css的选择器用法一模一样。层级选择器名称    用法    描述子代选择器    $(“ul>li”);    使用>号，获取儿子层级的元素，注意，并不会获取孙子层级的元素后代选择器    $(“ul li”);    使用空格，代表后代选择器，获取ul下的所有li元素，包括孙子等总结：跟css的选择器用法一模一样。过滤选择器名称    用法    描述:eq（index）    $(“li:eq(2)”).css(“color”, ”red”);    获取到的li元素中，选择索引号为2的元素，索引号index从0开始。:odd    $(“li:odd”).css(“color”, ”red”);    获取到的li元素中，选择索引号为奇数的元素:even    $(“li:even”).css(“color”, ”red”);    获取到的li元素中，选择索引号为偶数的元素总结：这类选择器都带冒号筛选选择器(方法)名称    用法    描述children(selector)    $(“ul”).children(“li”)    相当于$(“ul>li”)，子类选择器find(selector)    $(“ul”).find(“li”);    相当于$(“ul li”),后代选择器siblings(selector)    $(“#first”).siblings(“li”);    查找兄弟节点，不包括自己本身。parent()    $(“#first”).parent();    查找父亲eq(index)    $(“li”).eq(2);    相当于$(“li:eq(2)”),index从0开始next()    $(“li”).next()    找下一个兄弟prev()    $(“li”).prev()    找上一次兄弟总结：筛选选择器的功能与过滤选择器有点类似，但是用法不一样，筛选选择器主要是方法。# 详情跳转:https://blog.csdn.net/wuyxinu/article/details/103515157 ]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
